<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>HXHL&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://hxhl.github.io/"/>
  <updated>2020-05-22T23:13:47.280Z</updated>
  <id>http://hxhl.github.io/</id>
  
  <author>
    <name>HXHL</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>RIP:A Top-Down Approach</title>
    <link href="http://hxhl.github.io/2020/05/22/RIP/"/>
    <id>http://hxhl.github.io/2020/05/22/RIP/</id>
    <published>2020-05-22T14:22:22.000Z</published>
    <updated>2020-05-22T23:13:47.280Z</updated>
    
    <content type="html"><![CDATA[<p>我想通过一步一步的发明出『RIP』.通过这样的方法,相信能对『RIP』的理解会深刻不少.</p><h2 id="数据的传播方式"><a href="#数据的传播方式" class="headerlink" title="数据的传播方式"></a>数据的传播方式</h2><p>在这个网络中,所有的机子相连在一个『交换机』上,它们就是在一个局域网中,它们是怎么通信的呢？</p><p><img src="/images/RIP/%E5%9B%BE1.png" alt="alt"></p><p>主机A发给主机B一个数据包,但是其实这个局域网中的每一台机子都收到了这个数据包.但是它们会对数据做进行两次判断处理,来判断这个数据包,我是不是该接收.</p><p>首先,主机会先进行判断数据包是否是完整的(详细做法在这里,不繁述).如是数据包不是完整的,它们就会直接抛弃.</p><p>然后,它们进行第二次判断.判断这个数据包的目标地址,来确定是不是我该收的包(一种情况是目标地址就是自身ip,或者是一些特殊ip).</p><p>这个在一个局域网中,每次都是一台主机发,所有主机收.所以每次都只能有一台主机在发送数据,其它如果也发送, 就发生了冲突.我们就叫把这样一个网络叫做『冲突域』.</p><h2 id="路由原理"><a href="#路由原理" class="headerlink" title="路由原理"></a>路由原理</h2><p>因为冲突域每个机子都会收到同一份数据包.但是基本都是发给别人的会被抛弃的,这大大浪费了资源,如果真的这样搞,网络怎么能正常运行.我们可以让冲突域变的小一点,然后把几个冲突域连接在一起.这样似乎就能解决这个问题了.</p><p>可以如果一个数据出了冲突域.我要怎么知道去哪一个冲突域呢？我们就需要一个可以根据目标位置去转发到指定目标的『机器』</p><p>我们就发明一个叫『路由』的东西.它根据自身的路由表将不同的数据包不断地转发去他该去的冲突域中.</p><table><thead><tr><th align="left">ip</th><th align="center">子网</th><th align="right">接口</th></tr></thead><tbody><tr><td align="left">192.168.0.0</td><td align="center">255.255.255.0</td><td align="right">f0/1</td></tr><tr><td align="left">192.168.1.0</td><td align="center">255.255.255.0</td><td align="right">f0/2</td></tr><tr><td align="left">192.168.1.0</td><td align="center">255.255.255.0</td><td align="right">f0/3</td></tr></tbody></table><p>对于子网的不理解的人,可以去看我的『<a href="https://hxhl.github.io/2020/03/22/VLSM/">VLSM</a>』那一篇博文.</p><p>在思科路由中,我们通过</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">     ip route ip-address  netmask       interface</span><br><span class="line"># 例 ip route 192.168.1.1 255.255.255.0 f0&#x2F;1</span><br></pre></td></tr></table></figure><p>这样的命令去配置我们的路由表.</p><h2 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h2><p><strong>可以每次这样手动配置路由表也太麻烦了,有没有简单的办法配置路由？</strong></p><p>我们可以把每一台自己的路由表发送到其它的路由器上呀.这个网络中的每一台路由就都有整个网络的路由信息了.</p><p>那就让我们发明这样把自动配置路由信息的路由系统吧,我们把这个的系统叫做『动态路由』,然后制定一系列协议去规定该怎么交换路由信息.把这个叫做『路由协议』.</p><h3 id="发送功能"><a href="#发送功能" class="headerlink" title="发送功能"></a>发送功能</h3><p>第一个也是最重要的功能!把自己的路由表发给别的路由器, 每过几秒就进行一次发送.</p><p>嗯,这个时间太短,网络资源消耗太大.太长会使信息更新不及时.就挑一个合适的数字吧.每30秒发送一次.</p><h3 id="遇到第一个问题"><a href="#遇到第一个问题" class="headerlink" title="遇到第一个问题"></a>遇到第一个问题</h3><p><img src="/images/RIP/%E5%9B%BE2.png" alt="alt"></p><p><strong>如果一个远处的路由3坏掉了,我还是按着我的路由表转发,那这个数据可就远远到达不了它的目的地了.</strong></p><p>所以我想加入『根据情况变更路由表』的功能.</p><h3 id="自动失效功能"><a href="#自动失效功能" class="headerlink" title="自动失效功能"></a>自动失效功能</h3><p><strong>怎么去判定一个远程的路由是否失效呢？</strong></p><p>一个路由坏掉之后就不会再往外面发送信息了,那可以设计在一定时间内,我没有收到关于它的信息,那么判断它已经坏了!</p><p>把这个时间设成180s吧,反正一定要比30s长就行.如果在180s内没有收到关于一个路由的信息,那么它就是失效了.</p><h3 id="遇到第二个问题"><a href="#遇到第二个问题" class="headerlink" title="遇到第二个问题"></a>遇到第二个问题</h3><p>随着网络的运行,网络情况的不断改变,路由表里可能充满了已经失效的路由的数据,无论路由的内存有多大,总有一天会被占满,如果不把路由表里已经失效的路由数据给清除掉,就放不下一新的路由信息了.</p><p>所以我们还要一个『把失效的路由删除』的功能!</p><h3 id="删除功能"><a href="#删除功能" class="headerlink" title="删除功能"></a>删除功能</h3><p>一个路由可能因为各种不是本身的原因被认为失效.如果一失效就删除,似乎不太好,不如把这个路由标记为失效,不再使用它转发路由,然后给它一点机会.如果它确认失效的180s内收到它的信息,那么它就是恢复一个正常的路由,如果180秒期满再删掉它.</p><h3 id="遇到第三个问题"><a href="#遇到第三个问题" class="headerlink" title="遇到第三个问题"></a>遇到第三个问题</h3><p><strong>随着路由越来越大,一个路由失效每次传到一个路由里都要经过180秒,太慢了!有没有什么办法可以让远程的路由知道某个路由已经失效了？</strong></p><p><img src="/images/RIP/%E5%9B%BE3.png" alt="alt"></p><p>我们重新设计新的删除与发送能力.让路由主动告知别的路由,我已经知道的失效的路由的消息.让路由失效的消息更快的到达网络的每一个路由上.</p><p>直接删掉真的好吗？如果我把这个路由已经失效的消息告诉别人,而不是让每个路由都要硬等180s会不会更好呢?</p><h3 id="新的删除功能"><a href="#新的删除功能" class="headerlink" title="新的删除功能"></a>新的删除功能</h3><p>让每个路由在发送路由表的时候,带上已知的失效路由信息.同时让通知更久一些.在原先的删除机制上发动,一个路由失效180s期满后不直接删除.而是保持期满状态.而是让每个路由失效240s之后,再直接删掉.</p><h3 id="第四个问题"><a href="#第四个问题" class="headerlink" title="第四个问题"></a>第四个问题</h3><p><img src="/images/RIP/%E5%9B%BE4.png" alt="alt"></p><p><strong>现在同时我收到两个路由告诉我,它们都可以到达路由3,我该怎么选择呢？</strong></p><h3 id="路由计数"><a href="#路由计数" class="headerlink" title="路由计数"></a>路由计数</h3><p> 我们可以在路由信息上加上经过了几个路由,每经过一个路由的传播就增加一个,这个我就知道那条路径经过的路由最少了!</p><table><thead><tr><th align="left">ip</th><th align="center">接口</th><th align="right">Hop(要过几个路由)</th></tr></thead><tbody><tr><td align="left">192.168.0.0</td><td align="center">f0/1</td><td align="right">2</td></tr><tr><td align="left">192.168.1.0</td><td align="center">f0/2</td><td align="right">3</td></tr><tr><td align="left">192.168.1.0</td><td align="center">f0/3</td><td align="right">1</td></tr></tbody></table><h3 id="第五个问题"><a href="#第五个问题" class="headerlink" title="第五个问题"></a>第五个问题</h3><p><strong>有没有什么办法可以更简单的通知某一个路由已经失效了.最好不要改变原本的数据格式.</strong></p><h3 id="跳数上限"><a href="#跳数上限" class="headerlink" title="跳数上限"></a>跳数上限</h3><p>我们可以设定一个跳数上限,超过这个值就代表不可达的!可是多少好呢？</p><p>16个怎么样呢？由一个主机到别一个主机要经历16个路由器.不会吧,有这么庞大的网络吗？(rip设计的较早,那时没有这么庞大的网络,当然现在一个转发超过16个路由器的情况,所以rip现在只存在于一些小型的局域网中.)</p><p><strong>如果以后网络的真的超过16个路由呢？</strong></p><p>那以后有了.那也就以后的事以后再说吧!肯定会有新的支持大型网络的路由协议出来的.</p><p>当一个路由它的Hop为16,那么就代表它是不可达的!</p><h3 id="第六个问题"><a href="#第六个问题" class="headerlink" title="第六个问题"></a>第六个问题</h3><p><img src="/images/RIP/%E5%9B%BE7.png" alt="alt"></p><p><strong>我发现网络资源还是有被浪费.你看路由B收到路由C的路由表,如果再把来自路由C接收来的路由表发回去,多不合适呀.</strong></p><h3 id="水平分割"><a href="#水平分割" class="headerlink" title="水平分割"></a>水平分割</h3><p>我要加入一个功能『在发送路由信息时,不发送来自它发给我们的路由信息』</p><h3 id="第七个问题"><a href="#第七个问题" class="headerlink" title="第七个问题"></a>第七个问题</h3><p><img src="/images/RIP/%E5%9B%BE5.png" alt="alt"></p><p>这时候,路由1同时收到路由2说路由3坏了,拟路由1把路由3设置成了不可达,但是这时候路由4又告诉路由1,路由3是可以到达的.</p><p>这里可以是因为几种原因,路由3网络不稳定.路由4还没有收到路由3不可达的消息.或者还可能路由4是故意搞破坏的.或者路由2的消息才是错的.</p><p>我们应该怎么办呢？</p><h3 id="保持关闭"><a href="#保持关闭" class="headerlink" title="保持关闭"></a>保持关闭</h3><p>无论哪种情况,都说明这个路由3存在争论,我们可以通过强制这个网络保持一种情况一段时间,让我们不会前后不一.</p><p>不过是保持开启还是保持关闭呢？如果网络是坏的.保持关闭,可能会通过其它方法去绕路,可能还能到达.但是保持开启.那发的数据一定会全部丢失.如果网络是好的.保持关闭,也不过绕路而;保持开启,可以到达.</p><p><img src="/images/RIP/%E5%9B%BE6.png" alt="alt"></p><p>两种情况,保持关闭能比保持开启有更好的效果.所以我们把它设计成保持关闭.</p><h3 id="第八个问题"><a href="#第八个问题" class="headerlink" title="第八个问题"></a>第八个问题</h3><p>用什么方式把数据传出去呢？我可不知道别的路由的IP地址呀.</p><p>要是能像学校的广播一样,让全校(网络)的学生(路由)都能听见就好.</p><p>对了!那就让我们发明一个『广播』吧!</p><h3 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h3><p>广播的目标地址设成多少好呢?一定得是不是主机用的ip地址,否则大家的广播,传到他那里,还是广播吗？ip地址中1-254都有人用了,那就255吧(这是鸡生蛋或者蛋生鸡的问题,在历史上的TCP/IP的规范制定肯定与这个不相符,但是为了大家的理解,这样构造故事.)</p><p>255.255.255.255,嗯.不错!如果目标地址是这个,就代表它是发给所有人的!</p><p>我们的路由协议就这样设计完成了(当然细节不止这么点,我只挑了一些代表性的功能)</p><h3 id="RIP诞生"><a href="#RIP诞生" class="headerlink" title="RIP诞生!"></a>RIP诞生!</h3><p>这样一个动态路由就这样完成了, 我们决定为它取一个名字,就叫它『Routing Information Protocol(路由信息协议)』好了,简称RIP!</p><h3 id="遇到第九个问题"><a href="#遇到第九个问题" class="headerlink" title="遇到第九个问题"></a>遇到第九个问题</h3><p>使用广播会不会太浪费资源了,我们发给RIP路由的信息,只要发给RIP路由就好了,发给主机和交换机的或者其它路由真是太浪费了传输资源了.</p><p>我要发明一个能发给指定人的广播!</p><p>只有加入我们rip小组的机子才会收到这个广播.那就叫它组播吧!</p><h3 id="组播"><a href="#组播" class="headerlink" title="组播"></a>组播</h3><p>那挑个什么样的ip地址作我们的组播ip呢？还要是没有人用的.哎!反正没有人用的ip多了去了,比如在D类网络(224.0.0.0～239.255.255.255)就没有人用嘛!(这又是个鸡生蛋或者蛋生鸡的问题).</p><p>我们把我们的RIP的组播地址设成224.0.0.9!只要目标地址是这个,就代表是发给rip路由的数据包!</p><h3 id="第十个问题"><a href="#第十个问题" class="headerlink" title="第十个问题"></a>第十个问题</h3><p>呀!有个人发明了『<a href="https://hxhl.github.io/2020/03/22/VLSM/">VLSM</a>』.在VLSM中有的机子的子网掩码会有不同.但是我们之前会了省下网络资源,在网络信息中没有把子网掩码带上.这可能导致看起来在一个网络中的两个IP其实在两个网络中!</p><h3 id="带有子网信息的路由信息"><a href="#带有子网信息的路由信息" class="headerlink" title="带有子网信息的路由信息"></a>带有子网信息的路由信息</h3><p>所以我们在路由信息中不仅要有IP地址还要带上子网掩码,来精准的确实网络位置.</p><h3 id="新的RIP"><a href="#新的RIP" class="headerlink" title="新的RIP"></a>新的RIP</h3><p><strong>旧的RIP已经发布出去了, 我们又给旧的RIP加了点功能以适应不同的网络情况.可是它们又不互相兼容,该怎么办呢？</strong></p><p>我们把新的RIP称为RIP 2吧.以区分不同的RIP协议!</p><table><thead><tr><th align="left">旧RIP</th><th align="right">新RIP</th></tr></thead><tbody><tr><td align="left">RIPv1</td><td align="right">RIPv2</td></tr><tr><td align="left">最高15跳计数</td><td align="right">最高15跳计数</td></tr><tr><td align="left">广播</td><td align="right">组播</td></tr><tr><td align="left">不支持VLSM</td><td align="right">支持VLSM</td></tr></tbody></table><p>著作权归作者所有。<br>商业转载请联系作者获得授权，非商业转载请注明出处。<br>作者：HXHL<br>链接：<a href="https://hxhl.github.io/2020/05/22/RIP/">https://hxhl.github.io/2020/05/22/RIP/</a><br>来源：<a href="https://hxhl.github.io">HXHL’s Blog</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我想通过一步一步的发明出『RIP』.通过这样的方法,相信能对『RIP』的理解会深刻不少.&lt;/p&gt;
&lt;h2 id=&quot;数据的传播方式&quot;&gt;&lt;a href=&quot;#数据的传播方式&quot; class=&quot;headerlink&quot; title=&quot;数据的传播方式&quot;&gt;&lt;/a&gt;数据的传播方式&lt;/h2&gt;&lt;
      
    
    </summary>
    
    
    
      <category term="CCNA" scheme="http://hxhl.github.io/tags/CCNA/"/>
    
      <category term="计算机网络" scheme="http://hxhl.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Head Fisrt I3WM</title>
    <link href="http://hxhl.github.io/2020/04/22/I3WM/"/>
    <id>http://hxhl.github.io/2020/04/22/I3WM/</id>
    <published>2020-04-22T14:22:22.000Z</published>
    <updated>2020-05-12T06:19:39.387Z</updated>
    
    <content type="html"><![CDATA[<h1 id="凤头"><a href="#凤头" class="headerlink" title="凤头"></a>凤头</h1><p><strong>我可以从本文中学习到什么</strong>?<br>学习完本文,你将学会配置一个漂亮的 I3WM 桌面,与网上其它让你照猫画虎的文章不同,本文的目标是让你及时遇上一个问题时可以独立解决.比如当网上找不到遇到同样问题的时候,你就格外需要独立解决问题的能力.</p><p><strong>有什么要求吗?</strong></p><p>本文需要你拥有一点 Linux 基础,比如会使用 VIM.</p><p>让我猜猜你!</p><p>你可能会不少 Linux 命令,但是你用起来没有如 Windows 那个顺手,你知道去安装一个『软件』但是不知道如何去打开一个『软件』,或者不知道去设置『开机自启』.</p><p>你还可能是一个资深的 Linux 用户,已经用过『KDE』或者『Gnome』,但是你想了解一下 I3WM,但是你在使用别人的配置时遇上各种问题,你想了解一下 I3WM 的相关好去排错.</p><p>本文是在『Manjaro』上做的,但是 I3WM 是 Linux 的『窗口管理器』而并非只属于哪个特定的 Linux 版本,所以理论上本文的内容是可以在其它版本的 Linux 上使用的.</p><p><strong>有多漂亮呢?</strong></p><p>这是一张成品图</p><p><img src="/images/I3WM/finish.png" alt="finish"></p><p>它来自github用户『levinit』所分享的配置,<a href="https://github.com/levinit/i3wm-config" target="_blank" rel="noopener">项目链接</a>.十分感谢他分享自己的配置.</p><p><strong>我只想快一点搞个好看的 I3 主题怎么办?</strong></p><p>那请你使用本主题作者所使用的<a href="https://github.com/levinit/i3wm-config" target="_blank" rel="noopener">脚本</a>与看他的<a href="https://levinit.github.io/i3wm-config/" target="_blank" rel="noopener">教程</a>,本文更多是阐述I3WM 与其相关软件更深入的一面和教导你如何使用与配置.</p><h1 id="猪肚"><a href="#猪肚" class="headerlink" title="猪肚"></a>猪肚</h1><p><strong>那我应该怎么做</strong>?</p><p>现在这是我们现在最初的样子</p><p><img src="/images/I3WM/initial.png" alt="Initial"></p><p>我们可以看见,与上面所提到的成本品的区别,我将分别介绍如何实现它们.</p><p><strong>怎么打开终端?</strong></p><p>同时按下『Win 键』和『回车键』.</p><h3 id="壁纸"><a href="#壁纸" class="headerlink" title="壁纸"></a>壁纸</h3><p><strong>我该如何设置一张壁纸?</strong></p><p>I3WM 异或者是 Linux 均没有提供壁纸功能,所以我需要使用一款软件『feh』.</p><p><strong>我该如何得到它?</strong></p><p>如果你是『Arch』或者『Manjaro』的用户,可以使用<code>sudo  pacman -S  feh</code></p><p>如果是其它的 Linux 发行版,请使用 相应的包管理器安装该软件.</p><p><strong>我该如何设置一张图片做我的壁纸</strong></p><p><code>feh --bg-scale &quot;图片的路径&quot;</code></p><p>其中<code>--bg-scale</code>参数将会缩放你的图片,使其填满你的桌面.</p><p>如果你不想把缩放,请使用<code>--bg-fill</code></p><p><strong>为什么我重启电脑之后我的壁纸就没有了</strong>?</p><p>如果你有过一些电脑基础,你应该知道『程序自启』这个概念,我们的壁纸程序并没有设置『自启』,我将在下一小节中讲述如何使用.</p><h3 id="I3WM-的配置"><a href="#I3WM-的配置" class="headerlink" title="I3WM 的配置"></a>I3WM 的配置</h3><p>由 Mike Gancarz 所提出的 UNIX 哲学中的第五条</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5.Store data in flat text files.</span><br><span class="line">五.数据应该保存为纯文本文件。</span><br></pre></td></tr></table></figure><p>所以 I3WM 的配置也是保存在一个文本文件之中,你应该使用『VIM』或者其它文本编程器去编辑它们,并没有一个像『Windows』异或者是『MacOS』那样拥有一个『设置面板』.</p><p><strong>那 I3WM 的配置文件在哪里呢?</strong></p><p>它在你的<code>home</code>目录的<code>config</code>的<code>i3</code>文件夹中.如果你知道一点 Linux 知识的话,那你应该知道可以用<code>~</code>代指你的<code>home</code>目录.</p><p>所以你可以使用<code>cd ~/config/i3</code> 来进入你的 I3WM 配置文件目录.</p><p>其中的个名为<code>config</code>的文件就是你的I3WM 的配置文件.</p><p><strong>所以我应该如何让我的壁纸在重启之后不会消失呢?</strong></p><p>I3WM 在启动时就会读取它的配置文件,我们当然希望我们的壁纸跟 I3 一起启动.正好 I3WM 提供了这个功能!</p><p>现在回想一下我们设计壁纸的命令是什么?</p><p>对!是<code>feh --bg-scale &quot;图片的路径&quot;</code></p><p>我们将这段话添加到<code>config</code>文件之中,最好是在末尾!</p><p><code>exec --no-startup-id feh --bg-scale &quot;图片的路径&quot;</code></p><p><strong>我还可以做些什么?</strong></p><p>我觉得你可以举一反三了,<code>exec --no-startup-id 你需要执行的命令</code>,你可以把你想执行的命令加在<code>config</code>这样你的命令就会随着 I3WM 启动所执行了.</p><p>当然如果你的命令很多很长,你可以写在一个 shell文件 之中,然后通过 <code>exec</code>去执行你这个 shell文件 ,同时你可以在后面加上<code>&amp;</code>,让你的 Shell文件 或者 命令 转入到后台执行.不会把 I3WM 阻塞住.</p><p>例如:<code>exec --no-startup-id  ~/请换成shell的名字.sh &amp;</code></p><p><strong><code>--no-startup-id</code> 是什么意思啊?</strong></p><p>有些『脚本』或者『程序』并没有『启动提醒』,就是说它们启动之后并不会告诉系统,我启动好了.这会让你的系统认为我卡住了.导致你的鼠标指针处于忙碌状态.</p><p>这个参数可以解决这种情况.</p><h3 id="终端透明"><a href="#终端透明" class="headerlink" title="终端透明"></a>终端透明</h3><p><strong>我怎么才能把我的终端变成透明的?</strong></p><p>我们在设置壁纸时使用了『feh』,这次我们使用『xcompmgr』这款软件.</p><p><strong>为什么要用到这么多软件啊,有没有『全家桶』呀</strong>?</p><p>我们又要说到 UNIX 哲学了. Doug Mcllroy 这个人,和上面那个不是一个人呀,他提出了三条,其中第一条就是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.Write programs that do one thing and do it well</span><br><span class="line">一.写一个程序做一件事和把它做好.</span><br></pre></td></tr></table></figure><p>Linux 有太多小而美的软件,几乎没有大而全的软件.因为这一点也不 UNIX.</p><p><strong>我装好了,怎么用呢?</strong></p><p>请在终端中输入<code>xcompmgr &amp;</code>,<code>&amp;</code>是做什么用的,上文提到过了,你可以尝试把<code>&amp;</code>去掉,你就会发现程序运行在 前台 ,导致你的终端不能再输入其它命令了!</p><p><strong>也需要加入到<code>config</code>中让它自启吗?</strong></p><p>完美的一次举一反三!没错!请把这个加入其中<code>exec --no-startup-id xcompmgr &amp;</code></p><p><strong>我可以选择什么终端?</strong></p><p>这里推荐<code>roxterm</code>、<code>xfce-terminal</code>和<code>terminator</code>,因为它们更方便设置透明度.</p><p><strong>我使用的是 Manjaro I3,我的 xcompmgr(或者 compton) 不能启动,提示<code>Anoter composite manager is already running(picom)</code>.</strong></p><p>想学会『独立解决问题』就必须学会认真的看提示信息,报错写的非常清楚<code>Anoter composite manager is already running(picom)</code>,『其它的窗口管理器已经在运行(picom)』.显然易见因为已经在运行了一款叫做『picom』的软件.</p><p>如果你尝试去卸载它时,你还会发现报错,因为它和 i3WM 居然是依赖!这是 Manjaro I3 给你们预先装好的环境.出现什么问题,当然都不奇怪.既然都是窗口管理器<code>xcompmgr</code>能做的事<code>picom</code>也能做,那我们就可以去使用它把终端变透明吧!</p><p><strong>我要使用 urxvt 终端,怎么才能让它变透明?</strong></p><p>或许你的版本不能安装<code>terminator</code>,异或者你就是想使用<code>urxvt</code>.但是这个不是什么问题.并且能轻易在网上找到解决方案,你可以点击<a href="https://www.cnblogs.com/vachester/p/5649813.html" target="_blank" rel="noopener">这里参看一片关于配置 urxvt 的透明的教程, 它使用的是 compton(也叫 picom)</a>.感谢每位在无私在互联网上分享自己经验的人.</p><h3 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h3><p><strong>我可以不用快捷键吗?</strong></p><p>如果你使用的是『KDE』或者『Gnome』这些『窗口管理器』,你或许还可以不学,但是 I3WM 如你所见,并没有什么按钮供你去点击.所以你必须去学习与使用</p><p><strong>我需要要去背很长的快捷键表吗?</strong></p><p>当然不是! 我要教你的是如何设置与查看快捷键.</p><p>继续编辑我们的<code>config</code>,往上走.在最上面我们就能看见</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set $mod Mod4</span><br></pre></td></tr></table></figure><p>这句话是指把 Mod4 键设置$mod.</p><p><strong>Mod4 是哪个键?</strong></p><p>正常情况下是你键盘上那个『Win键』.</p><p><strong><code>$mod</code>是什么?</strong></p><p>我们称之为『Super key』,我通常把这个键和其它键来组成使用快捷键.</p><p><strong>里面有哪些设置好的快捷键?</strong></p><p>我们往下翻翻,就会看见</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bindsym $mod+s layout stacking</span><br><span class="line">bindsym $mod+t layout tabbed</span><br><span class="line">bindsym $mod+c layout toggle split</span><br></pre></td></tr></table></figure><p>如果你没有改动上面所说的$mod,那这里的意思就是说同时按下『Win 键』和『S 键』时,将窗口堆叠模式改成『堆叠式』(stacking).按下『Win 键』和『 T 键』 就是『标签式』(tabbed),而『Win 键』加上『C 键』可以让你在 垂直平铺和水平平铺之间 来回切换.</p><p>动手试试吧,不要光看不用!你会爱上这种操作方式的!绝对会!</p><p><strong>我可以让某个快捷键启动一个程序吗?</strong></p><p>当然!我希望你能在这里继续举一反三!我们把这句添加进去.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bindsym $mod+F2 exec firefox</span><br></pre></td></tr></table></figure><p>我觉得你已经能够理解了!当按下『Win 键』和『 F2 键』时, Firefox 就会启动了!把按键和软件换成你想换的吧!</p><h3 id="举一反三"><a href="#举一反三" class="headerlink" title="举一反三"></a>举一反三</h3><p><strong>所以启动 Linux 软件就是在终端输入它的名字吗?</strong></p><p>在上面的学习过程中,你应该知道『软件』和启动是和 执行命令 是一样,就像你启动<code>firefox</code>和执行其它命令是一样的.</p><p><strong>可以在软件名后面加上<code>&amp;</code>让它不阻塞我的终端吗?</strong></p><p>是的!如果你对知识足够敏感,我觉得你已经可以从上文中学会了这种方式,在命令行中输入你软件的名字,并且在后面加个<code>&amp;</code>,软件就在会后面独立运行.否则,当你关掉终端时,你的软件也会跟着关闭.</p><p><strong>软件名太长了,我也记不住啊,有没有怎么简单的办法启动软件?</strong></p><p>有的!这种软件在 Linux 当中叫做『软件启动器』.</p><p><img src="/images/I3WM/Synapse.png" alt="Synapse"></p><p>比如图中我所使用的叫做<code>Synapse</code></p><p><strong>启动软件要软件启动器,那我怎么启动软件启动器这个软件?</strong></p><p>这并不是一个勃论.很简单,在上一张,我们就谈到通过快捷键启动<code>firefox</code>,你相信你已经反应过来的.如何去启动『软件启动器』.</p><h2 id="豹尾"><a href="#豹尾" class="headerlink" title="豹尾"></a>豹尾</h2><h3 id="学会独立的解决问题"><a href="#学会独立的解决问题" class="headerlink" title="学会独立的解决问题"></a>学会独立的解决问题</h3><p><strong>我使用的是文章开头所引用的配置?但是有一些奇怪的 BUG,我该怎么办?</strong></p><p><strong>我使用是别人的配置,但是有一些奇怪的 BUG,我该怎么办?</strong></p><p>这两个问题我想放在一起回答,因为各种各样的问题,永远没有一个长久的解决办法,我不能希望每次都能在互联网上找到对症下病的解决办法,你必须学会去排查去独立的解决问题.</p><p>以开头所引用的配置为例,随着时间的变动,有一些软件已经改名,停止更新,或者已经不提供下载了.那个配置所需要的一个 i3block 的程序,已经无法通过<code>pacman</code>或者<code>yay</code>安装,或许你现在尝试时没有任何问题.但是这不是问题,问题是『当我们遇到缺少依赖时,我们就应该怎么办?』.</p><p>我这样当然不是教你如何自己编写一个依赖,而让你去放弃这个功能或者换个可以用的让整个程序没有问题运行起来.啊!我看的出你现在很失望.不过这确实是一个简单易行的解决办法!人生总有要放弃的.当然你也可以选择放弃时间,把时间投入在寻找依赖的时间黑洞上.</p><p>一般来讲,你可以很清楚的看清错误信息的,然后在 I3WM(如果你要解决的是其它问题,请在找到它的配置)的配置文件,中找到大致的地方.比如文头所引用的配置,因为 i3block 的消失,导致 i3bar 不能用,当然是在 <code>config</code> 中的找到<code>bar</code>的相关配置.</p><p>找到一个大的方向之后,你就可以通过 注释或者删掉 的办法去准确去定位到底是哪个地方出了问题.当然这个过程是相当麻烦的.可能就算成功了也没有多少成就感.但是可能是一个 Linuxer 的必修课.</p><h4 id="中文输入-fcitx-fcitx-fcitx"><a href="#中文输入-fcitx-fcitx-fcitx" class="headerlink" title="中文输入 fcitx fcitx fcitx!"></a>中文输入 fcitx fcitx fcitx!</h4><p><strong>我已经按照网上的解决办法安装<code>fcitx</code>和<code>fcitx-im</code>还有<code>fcitx-rime</code>,同时在<code>/etc/profile</code>加入那三行,可是还是不能输入中文!</strong></p><p>在<code>/etc/profile</code>加入这三行.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export XMODIFIERS&#x3D;&quot;@im&#x3D;fcitx&quot;</span><br><span class="line">export GTK_IM_MODULE&#x3D;&quot;fcitx&quot;</span><br><span class="line">export QT_IM_MODULE&#x3D;&quot;fcitx&quot;</span><br></pre></td></tr></table></figure><p>几乎是网上所有能找到的不能使用 fcitx教程的解决办法. 你也照做,但是你还是不能用?这是为什么呢?</p><p>本文的目标是希望你能『独立的解决问题』,我希望以此为例,来说明如何一步步的定位与解决问题.</p><p>如果你安装了 fcitx,还在 <code>config</code>设置了程序自启(或者你启动了 fcitx),你可以在托盘图标中轻易的找到一个键盘(或者是其它)图标,你会发现,它是 fcitx 的图标托盘.</p><p>右击它.在那么多的菜单中.我们可以一个个的看看是哪里出现了问题.</p><p>哦!在 <code>Input Method</code>只有<code>Keyboard - English(US)</code>一个而没有中文!</p><p>就是这样我们要把问题一步步缩小与明确.</p><p>那我们现在就要在 <code>Input Method</code>中添加一个中文输入方式.</p><p>你相信你会发现<code>Configure</code>,并且你发现,点击就会报错.我们看看报错信息,无论你会不会英语(不会就用电脑翻译!),你就会知道是缺少程序!那简单,我们就通过<code>pacman</code>(如果你是其它 Linux 请使用相应的包管理)去安装.它不仅告诉我缺少程序!还告诉我们,程序在不同版本Linux 上的可能的名字.安装它!</p><p>打开<code>Configure</code>,你肯定会点下面的<code>+</code>,这一看就知道是添加新的输入方式的.你或许在跳出来的列表中找不到『Chinese』,但是你也可能会注意到『Only Show Current Language』,如果你找不到『Chinese』,就把它取消掉吧.</p><p>现在你无论如何都可以找到『Chinese』了吧.就这样添加上,你就可以正常的输入中文.</p><p><strong>你说了这么多,情况变了怎么办?</strong></p><p>本文目标是希望能你够『独立的解决问题』,上文只是希望能够理解如何去排查一个问题定位一个问题,然后去解决它.上面的具体步骤不能帮助你去应对不同情况,但是不断缩小问题与明确问题的是解决每个问题的必经之路!</p><h3 id="锦上添花"><a href="#锦上添花" class="headerlink" title="锦上添花"></a>锦上添花</h3><p><strong>我看完了全文,但是除了基础的配置以外,我还是不懂得修改一个主题的外观.</strong></p><p>这是一个更深入的问题,我暂时还不能提供帮助,不过你可以在<a href="https://i3wm.org/docs/userguide.html" target="_blank" rel="noopener">这里</a>找到你想要的.如果可能,我以后将会发一篇新文章进行更深入的讲解.</p><p><strong>我还想要更多的主题,我可以在哪里找到它们?</strong></p><p>你可以在<a href="www.github.com">Github</a>搜索『<a href="https://github.com/search?q=i3wm" target="_blank" rel="noopener">i3wm</a>』,有许多人在上面发布了自己的 config.</p><p>例:</p><p><a href="https://github.com/Algorithm79/Dotfiles_i3" target="_blank" rel="noopener">Dotfiles_i3</a></p><p><img src="/images/I3WM/Dotfiles_i3.png" alt="Dotfiles_i3"></p><p><a href="https://github.com/CSaratakij/i3-rice-rin-shelter" target="_blank" rel="noopener">Rin : shelter</a></p><p><img src="/images/I3WM/Rin-shelter.png" alt="Rin-shelter"></p><p><a href="https://github.com/TxGVNN/i3-config" target="_blank" rel="noopener">TxGVNN</a></p><p><img src="/images/I3WM/TxGVNN.png" alt="TxGVNN "></p><p><strong>什么是凤头猪肚豹尾?</strong></p><p>语出自元代陶宗仪《南村辍耕录》：『乔吉博学多能，以乐府称，尝云：“作乐府亦有法，曰凤头、猪肚、豹尾六字是也。”大致起要美丽，中要浩荡，结要响亮。尤贵在首尾贯穿，意思清新。苟能若是，斯可以言乐府矣。』</p><p>我希望我的博文能写得『凤头猪肚豹尾』,或许现在我的博文还配不上这六字,但这是我会不断的进步,希望有一天,能配的上这六个字.</p><p>著作权归作者所有。<br>商业转载请联系作者获得授权，非商业转载请注明出处。<br>作者：HXHL<br>链接：<a href="https://hxhl.github.io/2020/04/22/I3WM/">https://hxhl.github.io/2020/04/22/I3WM/</a><br>来源：<a href="https://hxhl.github.io">HXHL’s Blog</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;凤头&quot;&gt;&lt;a href=&quot;#凤头&quot; class=&quot;headerlink&quot; title=&quot;凤头&quot;&gt;&lt;/a&gt;凤头&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;我可以从本文中学习到什么&lt;/strong&gt;?&lt;br&gt;学习完本文,你将学会配置一个漂亮的 I3WM 桌面,与网上其它让你照猫画
      
    
    </summary>
    
    
    
      <category term="Linux" scheme="http://hxhl.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>WHAT?HOW?WHY? for VLSM</title>
    <link href="http://hxhl.github.io/2020/03/22/VLSM/"/>
    <id>http://hxhl.github.io/2020/03/22/VLSM/</id>
    <published>2020-03-22T14:22:22.000Z</published>
    <updated>2020-05-12T06:19:21.881Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-What-is-VLSM"><a href="#1-What-is-VLSM" class="headerlink" title="1.What is VLSM"></a>1.What is VLSM</h2><p><strong>什么是VLSM?</strong></p><p>vlsm的中文名叫『可变长子网掩码』,是一种网络技术.</p><h2 id="2-Why-is-VLSM"><a href="#2-Why-is-VLSM" class="headerlink" title="2.Why is VLSM?"></a>2.Why is VLSM?</h2><p>这章不讲原理也不讲怎么用,我们来讲讲VLSM可以帮助我们做什么.</p><p><strong>我们为什么要使用VLSM?</strong></p><p>因为VLSM可以帮助我们节省IP地址,减少网络范围,前者的好处不言自明,后者则可以减轻路由器的负担.</p><p><strong>它是怎么把一个大网络分成几个小网络的?</strong></p><p>在下一章的原理部分,我们会详细的讲述的.</p><h3 id="有类网络与无类网络"><a href="#有类网络与无类网络" class="headerlink" title="有类网络与无类网络"></a>有类网络与无类网络</h3><p><strong>什么样的网络是有类网络呢?</strong></p><p>A类、B类、C类网络就是有类网络,也就是说当一个网络中所有主机的子网掩码都一样时,那么这个网络就是有类网络.</p><p><strong>什么样的网络是无类网络呢?</strong></p><p>一个网络中有任意有一台主机的子网掩码不同于其它主机的子网掩码时,那么这个网络就是无类网络.比如一台主机的子网掩码是255.255.255.240,另一台主机的子网掩码是255.255.255.252</p><p><strong>那有类网络与无类网络在实际应用中有什么区别呢?</strong></p><p>一个网络如果是无类网络,那么它就只能使用RIPv2与OSPF等为无类网络所设计的路由协议,因为这些路由协议,会在路由通信时,带上主机的子网掩码,而RIP等路由协议将认为所有的网络接口都是同样的子网掩网,那么它就不会带上子网掩码.</p><p><strong>那有类网络和无类网络与VLSM有什么关系呢?</strong></p><p>VLSM是通过向子网掩码借位实现的,所以只要使用了VLSM,那么这个网络就是无类网络.</p><h2 id="3-How-is-VLSM"><a href="#3-How-is-VLSM" class="headerlink" title="3.How is VLSM?"></a>3.How is VLSM?</h2><p>了解了VLSM的优点和为什么要使用它,那我们就开始讲解VLSM的原理了.</p><h3 id="VLSM的原理"><a href="#VLSM的原理" class="headerlink" title="VLSM的原理"></a>VLSM的原理</h3><p>IP地址是由网络号与主机号组成的,我们可以通过子网掩码与IP地址进行运算,那我们就可以把一个IP地址分成网络号与主机号.</p><p><img src="/images/VLSM/%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="alt"></p><p>如图所示,我们通过把0改成1,那么IP地址所在的IP位就从主机号,变成了网络号的一部分.</p><h3 id="在C类网络上划分"><a href="#在C类网络上划分" class="headerlink" title="在C类网络上划分"></a>在C类网络上划分</h3><p><strong>VLSM可以在哪些网络上使用?</strong></p><p>Vlsm当然可以A类B类任意网络上划分,不过一般来说C类用的更多也更直观.且在学完之后,你也可以在A类B类网络上使用VLSM了.</p><p>我现在将为你展示不同的子网掩码和它与IP地址的联系(在C类网络中).</p><table><thead><tr><th align="center">前缀</th><th align="center">子网掩码</th><th align="center">能用的主机数</th><th align="center">占用IP地址数</th><th align="right">子网掩码(二进制)</th></tr></thead><tbody><tr><td align="center">/24</td><td align="center">0</td><td align="center">254</td><td align="center">256</td><td align="right">00000000</td></tr><tr><td align="center">/25</td><td align="center">128</td><td align="center">126</td><td align="center">128</td><td align="right">10000000</td></tr><tr><td align="center">/26</td><td align="center">192</td><td align="center">62</td><td align="center">64</td><td align="right">11000000</td></tr><tr><td align="center">/27</td><td align="center">224</td><td align="center">30</td><td align="center">32</td><td align="right">11100000</td></tr><tr><td align="center">/28</td><td align="center">240</td><td align="center">14</td><td align="center">16</td><td align="right">11110000</td></tr><tr><td align="center">/29</td><td align="center">248</td><td align="center">6</td><td align="center">8</td><td align="right">11111000</td></tr><tr><td align="center">/30</td><td align="center">252</td><td align="center">2</td><td align="center">4</td><td align="right">11111100</td></tr></tbody></table><p>我们可以根据一个路由接口所需要的主机数,去挑选一个合适大小的子网掩码给你所划分的新网络.</p><p><strong>能不能演示一下怎么划分一个网络</strong></p><p>好的,我现在将划分『192.168.10.0』这个大网络,把它划分成三个小网络.</p><table><thead><tr><th>IP</th><th align="right">图例</th></tr></thead><tbody><tr><td>0</td><td align="right"></td></tr><tr><td>16</td><td align="right">第一个网络-192.168.10.1/27</td></tr><tr><td>32</td><td align="right">———————————————</td></tr><tr><td>48</td><td align="right"></td></tr><tr><td>64</td><td align="right">第二个网络-192.168.10.33/27</td></tr><tr><td>80</td><td align="right">———————————————</td></tr><tr><td>96</td><td align="right">第三个网络-192.168.10.81/28</td></tr><tr><td>112</td><td align="right">———————————————</td></tr><tr><td>128</td><td align="right"></td></tr><tr><td>144</td><td align="right"></td></tr><tr><td>160</td><td align="right"></td></tr><tr><td>176</td><td align="right"></td></tr><tr><td>192</td><td align="right"></td></tr><tr><td>…</td><td align="right">省略</td></tr></tbody></table><p>这样我就得到了三 个小网络</p><table><thead><tr><th align="center">网络</th><th align="center">可用IP范围</th><th align="center">子网掩码</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">192.168.10.2-192.168.10.31</td><td align="center">255.255.255.224</td></tr><tr><td align="center">2</td><td align="center">192.168.10.33-192.168.10.79</td><td align="center">255.255.255.224</td></tr><tr><td align="center">3</td><td align="center">192.168.10.81-192.168.10.111</td><td align="center">255.255.255.240</td></tr></tbody></table><p><strong>为什么可用IP范围头尾少了二个IP</strong></p><p>你观察的真细节,确实如此,这二个IP在网络中另有他用,它们维持着网络,使网络能正常工作,所以不能把这两个IP给其它人.</p><p><strong>划分子网的有什么规则吗?</strong></p><p>有,每一个网络的开始IP必须是它所占有IP地址数量的整数倍,因为这样才能知道这个网络的范围与判断任意一个IP是属于哪一个网络的.</p><p><strong>划分子网有什么技巧吗?</strong></p><p>建议网络自大往小的分划.这样肯定可以让每一个子网的开始IP与结束IP都是相连的,可以减少因为必须是整数的开始所空置的IP.</p><p><strong>每划分一个网络,那么就要失去一个网络的头与尾两个ip,但是如果不把网络进行划分就有254个IP可以使用,而把网络细划就会失去更多的头尾两个IP,导致可用IP比254还要少,为什么反而能节省IP地址?</strong></p><p>确实每划分一个网络,那么这个网络就要使用两个IP去使这个网络能正常使用.</p><p>但是为什么能节省IP地址呢?那是因为路由器有一个要求,即一个路由器的两个接口是不能在同一个网络之中.</p><p>如果不使用VLSM细分网络的话,那么给一个路由器接口分配IP地址至少就要分配一个C类网络,可C类网络可是有254个IP地址可以使用呀.如果路由器用不完254个,那剩余未分配的IP地址就被空置着,且不能被其实接口的主机使用.</p><p>著作权归作者所有。<br>商业转载请联系作者获得授权，非商业转载请注明出处。<br>作者：HXHL<br>链接：<a href="https://hxhl.github.io/2020/03/22/VLSM/">https://hxhl.github.io/2020/03/22/VLSM/</a><br>来源：<a href="https://hxhl.github.io">HXHL’s Blog</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-What-is-VLSM&quot;&gt;&lt;a href=&quot;#1-What-is-VLSM&quot; class=&quot;headerlink&quot; title=&quot;1.What is VLSM&quot;&gt;&lt;/a&gt;1.What is VLSM&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;什么是VLSM?&lt;/stro
      
    
    </summary>
    
    
    
      <category term="CCNA" scheme="http://hxhl.github.io/tags/CCNA/"/>
    
      <category term="计算机网络" scheme="http://hxhl.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
</feed>
